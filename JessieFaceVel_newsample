%% for Jessie
startup;
mrstModule add agmg incomp agglom coarsegrid libgeometry
addpath(genpath('FVtools'));
 
%% INPUT DATA HERE
%load geopack.mat
sample = new_sample(1:152,1:152,1:150);
[distgeo3,idx3] = bwdist(sample,'euclidean');
R = 9.0e-6; %4.625e-6 geopack150, 5.36e-6 for bent150; 10e-6 for geopack and 5.3e-6 for bentheimer and berea sandstones
Shape = 1;
%shape 1 is tube, 2 is fractures
 
%% default flow direction is Z
% Flow direction can be changed
 %sample = permute(sample,[1 3 2]); %Y direction
 %sample = permute(sample,[3 2 1]); %X direction
 
%%
rho = 1;
mu = 0.001; %Pa.s = kg/(m.s)
P1 = 0.0000239/R^2; %0.0000177 for geopack150; 0.0000239/R^2 for bent150; 1000 is over 150m3 sample, so use 1000/R to impose 1000Pa over real sample size
P2 = 0;
%clear 
Ax = size(sample,1);
Ay = size(sample,2);
Az = size(sample,3);
 
%% connectivity check
 
        disp('Microporosity flag inactive, removing disconnected flow partitions')
        sample=~sample;
        CC=bwconncomp(sample,6);
        disp(['Identification complete: ',num2str(CC.NumObjects),' partitions identified'])
        % check each partition for end to end opening. if a partition is a
        %single part, and open on both sides, it must be connecte
        %throughout
        indexMap=[1:numel(sample)]';
        disp('Filtering...')
        for i=1:CC.NumObjects
            if numel(CC.PixelIdxList{i})<Az
                CC.PixelIdxList{i}=[];
%                 geoTemp=zeros(size(sample));
%                 geoTemp=geoTemp(:);
            end
        end
        CC.PixelIdxList=CC.PixelIdxList(~cellfun('isempty',CC.PixelIdxList));
        if numel(CC.PixelIdxList(:))>1
            for i=1:numel(CC.PixelIdxList(:))
                [~,~,z]=ind2sub([Ax Ay Az],CC.PixelIdxList{i});
                numIn=sum(z==1);
                numOut=sum(z==Az);
                if numIn==0
                    CC.PixelIdxList{i}=[];
                elseif numOut==0
                    CC.PixelIdxList{i}=[];
                end
            end
        end
        CC.PixelIdxList=CC.PixelIdxList(~cellfun('isempty',CC.PixelIdxList));
        disp(['Removal complete: ',num2str(numel(CC.PixelIdxList(:))),' connected partitions identified'])
        CC.PixelIdxList=cell2mat(CC.PixelIdxList');
        sample(sample==0)=1;
        sample=sample(:);
        sample(CC.PixelIdxList)=0;
        sample=reshape(sample,[Ax Ay Az]);
 
        clear indexMap
        clear z
        
        
poro2 = sum(sample(:)==0)/(Ax*Ay*Az)
[distgeo,idx] = bwdist(sample,'euclidean');
%clear sample      
 
 
 
 
%%
%local w
disp('calculating local conductivity')
 
 
% maxdist = size(unique(distgeo(:)),1);
 maxdist = max(distgeo(:)) 
[w, Dmax] = FindWW3(distgeo,maxdist,Ax,Ay,Az,Shape,R,mu);
w=w(:);
w_org = w;
 
%clear sample
 
w = reshape(w,Ax,Ay,Az);
%w2 = imresize3(w,0.5)
 
%Calculate mean pore size
 
 
 
%%
%Put on top of my code
%nx = Ax; ny = Ay; nz = Az;
%G = cartGrid([nx, ny, nz], [nx, ny, nz]);
%load G.mat
active = find(sample == 0);
G = extractSubgrid(G1, active);
clear active sample
G = mcomputeGeometry(G);
 
%% Set rock and fluid data
 
disp('Set rock and fluid data and Trans')
 
rock = makeRock(G, 1.*darcy(), 1);
 
rock.perm = w(:);
rock.poro=ones(G.cells.num,1);
%G=removeCells(G,G.cells.indexMap(rock.perm==0|isnan(rock.perm)));
rock.perm=rock.perm(rock.perm>0);
rock.poro=ones(G.cells.num,1);
 
rock.poro=ones(G.cells.num,1);
disp('Trans TPFA')
tic
T         = computeTrans(G, rock);
 
%T         = computeMimeticIP(G, rock, 'Verbose', true, ...
                 %     'InnerProduct', 'ip_quasitpf');
 
toc
gravity off;
fluid     = initSingleFluid('mu' ,    1*centi*poise     , ...
                            'rho', 1014*kilogram/meter^3);
 
%clear w
                        
% Set boundary conditions
 
disp('Set boundary conditions')
 
% resSol = initResSol(G, 0.0);
% bc     = fluxside([], G, 'LEFT',  1*meter^3/day());
% bc     = pside   (bc, G, 'RIGHT', 0);
 
 
resSol = initResSol(G, 0.0);
% [bFaces,bFaceCells] = boundaryFaces(G);
% 
%                 [x,inda,indb]=unique(bFaceCells);
%                 clear bFaceCells
%                 clear x
%                 
%                 bFaces=bFaces(inda);
%                  clear inda
%                  clear indb
%                     tol=1e-4;
%                 west = abs(G.faces.centroids(bFaces,3))<tol;
%                 east = abs(G.faces.centroids(bFaces,3)-max(G.nodes.coords(:,3)))<tol;
 
%                bc=[];
%                 tol=1e-4;
%                 west = abs(G.faces.centroids(bFaces,3))<tol;
%                 east = abs(G.faces.centroids(bFaces,3)-max(G.nodes.coords(:,3)))<tol;
%                 bc = addBC(bc, bFaces(west), 'pressure',1);
%                 bc = addBC(bc, bFaces(east), 'pressure',0);
% 
%                 clear east
%                 clear west
%                 clear bFaces
 
faceIndexList=[1:G.faces.num]';        
bc=[];                 
bcFaces = G.faces.centroids(:,3)== 0; % find the centroids on the faces
bc = addBC(bc, faceIndexList(bcFaces), 'pressure',P1/1000);
%bc = addBC(bc, faceIndexList(bcFaces), 'pressure',1);
bcFaces = G.faces.centroids(:,3)== Az; % find the centroids on the faces 
bc = addBC(bc, faceIndexList(bcFaces), 'pressure',P2/1000);
%bc = addBC(bc, faceIndexList(bcFaces), 'pressure',0);
 
%           
 
% bc = []
% %  bc = pside   (bc, G, 'TOP',  1);
%  bc = pside([], G, 'bottom', 10*barsa());
 
 
% Solve the linear system
%%
 
disp('Solve')
 
mrstModule add agmg
tic
 
%For Windows OS...
%  resSol = incompTPFA(resSol, G, T, fluid, 'bc', bc, ...
%                     'LinSolve', @(A,b) agmg(A,b));
  
%For Mac OS...
                        resSol = incompTPFA(resSol, G, T, fluid, ...
                   'bc', bc, 'MatrixOutput', true);        
                
                        toc  
 
                
                        toc  
%% plotting 3D pressure field
 
% clf
% plotCellData(G, convertTo(resSol.pressure(1:G.cells.num), barsa()));
% title('Cell Pressure [bar]')
% xlabel('x'), ylabel('y'), zlabel('Depth');
% view(3); camproj perspective; axis tight;
% colorbar
 
 
%%
 
disp('Calculate Perm')
 
dFluxCell=faceFlux2cellVelocity(G,resSol.flux);
dFluxCell(isnan(dFluxCell)) = 0;
 
xvel = dFluxCell(:,1)./R;
yvel = dFluxCell(:,2)./R;
zvel = dFluxCell(:,3)./R;
 
 
%flow in z direction
Lz = Az;
Lx = Ax;
Ly = Ay;
 
zVel2=zeros(Lz*Ly*Lx,1);
zVel2(G.cells.indexMap)=zvel;
zVel2=reshape(zVel2,[Lx Ly Lz]);
 
yVel2=zeros(Lz*Ly*Lx,1);
yVel2(G.cells.indexMap)=yvel;
yVel2=reshape(yVel2,[Lx Ly Lz]);
% 
xVel2=zeros(Lz*Ly*Lx,1);
xVel2(G.cells.indexMap)=xvel;
xVel2=reshape(xVel2,[Lx Ly Lz]);
 
 
Area = ones(Lz,1).*R^2;
q = zeros(Lz,1);
tempuz = zeros(Lz,1);
for k = 1:Lz;
tempuz(k) = sum(sum(zVel2(:,:,k)));
end
q1 = tempuz(:).*Area;
 
%figure(1002)
%plot(q1)
meanq2 = mean(q1)
 K2 = (Lz/(Lx*Ly))*mu*((meanq2*1)/(P1-P2))/(R^2*1)*10^12 %Darcy
 
 %%
 
m = createMesh3D(Ax, Ay, Az, Ax, Ay, Az);
 
D_val = zVel2; % value of the diffusion coefficient
D = createCellVariable(m, D_val); % assign the diffusion coefficient to the cells
D_face = harmonicMean(D);
zvel = D_face.zvalue;
zvel(isnan(zvel)) = 0;
 
D_val = yVel2; % value of the diffusion coefficient
D = createCellVariable(m, D_val); % assign the diffusion coefficient to the cells
D_face = harmonicMean(D);
yvel = D_face.yvalue;
yvel(isnan(yvel)) = 0;
 
 
D_val = xVel2; % value of the diffusion coefficient
D = createCellVariable(m, D_val); % assign the diffusion coefficient to the cells
D_face = harmonicMean(D);
xvel = D_face.xvalue;
xvel(isnan(xvel)) = 0;
